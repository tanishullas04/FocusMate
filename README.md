# FocusMate

FocusMate is an open-source Flutter application designed to help students track
assignments, subjects, deadlines and study sessions. The app synchronizes
per-user data with Firebase (Authentication + Cloud Firestore) and falls back
to local storage when Firebase is unavailable.

This README is written for developers and contributors. It covers setup,
Firebase configuration, security rules, seeding, debugging, testing, and
contribution guidelines. The goal is to provide a single, practical guide
that helps you get the project running and contributing quickly.

---

CONTENTS

- Quick start
- Firebase configuration
- Firestore security rules (recommended)
- Project layout and important files
- Data model and Firestore layout
- Running the app locally (platform examples)
- Seeding Firestore (manual & automated)
- Debugging and diagnostics
- Tests and CI notes
- Contributing and code style
- Changelog
- License and contact

---

QUICK START

1. Install Flutter and ensure the toolchain is healthy:

   flutter --version
   flutter doctor

2. Fetch project dependencies from the repository root:

   flutter pub get

3. Verify Firebase configuration exists at `lib/firebase_options.dart`.
   The file is typically generated by the FlutterFire CLI and must match the
   Firebase project you intend to use.

4. Run the app for development:

   # Web
   flutter run -d chrome

   # macOS desktop
   flutter run -d macos

   # Android / iOS
   flutter run

5. Register or sign in with a test account. The app will load the
   authenticated user's data from Firestore and show subjects/assignments.

---

FIREBASE CONFIGURATION

This repository relies on `lib/firebase_options.dart` for Firebase initialization.
If you need to connect the app to a different Firebase project use the
FlutterFire CLI to reconfigure the project.

Install the CLI and configure:

   dart pub global activate flutterfire_cli
   flutterfire configure

Pick the Firebase project and platforms you need. The CLI updates
`lib/firebase_options.dart` accordingly.

Make sure the following Firebase products are enabled for the project you use:

- Authentication (enable Email/Password for quick testing)
- Cloud Firestore
- (Optional) Firebase Storage for attachments

---

RECOMMENDED FIRESTORE RULES

The app stores user data under `users/{uid}` with nested subcollections. Use
the rules below to restrict access so only an authenticated user can read and
write their own documents.

Paste and Publish this in Firebase Console → Firestore → Rules:

```js
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

Important notes:

- These rules are intentionally restrictive and appropriate for private user
  data. Do not publish overly permissive rules to production.
- For one-off troubleshooting you may temporarily set `allow read, write: if true;`
  but revert immediately after testing.

---

PROJECT LAYOUT (HIGHLIGHTS)

The key files and directories to inspect when exploring the codebase:

- `lib/main.dart` — Flutter app entry; initializes Firebase and providers.
- `lib/firebase_options.dart` — generated Firebase config (project ids, keys).
- `lib/services/firebase_service.dart` — Firestore read and write helpers.
- `lib/services/auth_service.dart` — Authentication helpers, profile writes.
- `lib/providers/app_provider.dart` — Central application state and sync logic.
- `lib/models/` — Domain models: `assignment.dart`, `subject.dart`, etc.
- `lib/pages/` and `lib/widgets/` — UI code for screens and reusable widgets.

Read these files to understand how data flows from UI → provider → service →
Firestore (or local storage fallback).

---

DATA MODEL & FIRESTORE LAYOUT

All user data is stored under the user's document and nested collections:

- `users/{uid}` (document): profile fields such as `uid`, `displayName`, `email`, `createdAt`.
- `users/{uid}/subjects/{subjectId}`: Subject documents (id, name, color, credits).
- `users/{uid}/assignments/{assignmentId}`: Assignment documents (id, title, dueDate, subjectId, priority, completed, notes).
- `users/{uid}/settings/user_settings`: App settings for the user.

The `FirebaseService` in `lib/services/firebase_service.dart` exposes CRUD
operations for these collections and the `AppProvider` orchestrates reads/writes.

---

RUNNING THE APP LOCALLY (DETAILS)

Development notes:

- Use hot reload (`r`) while running with `flutter run` to iterate quickly.
- For web development open DevTools (F12) to view network requests and logs.
- If Firebase fails to initialize the app will report the error and use local
  storage instead; check `lib/firebase_options.dart` and network access.

Example run commands:

```bash
# Web
flutter run -d chrome

# macOS
flutter run -d macos

# Android emulator
flutter run -d emulator-5554
```

---

SEEDING FIRESTORE

Manual seeding (quick):

1. Open Firebase Console → Firestore → Start collection `users`.
2. Add a document whose ID matches your signed-in UID.
3. Create `subjects` and `assignments` subcollections and add documents
   matching the app model fields.

Automated seeding (recommended for repeatability):

Create `seed/firestore-seed.js` with the example script below and run it with
a Firebase service account key. This is safe for development and CI seeding.

Example Node.js seeder (to add to `seed/firestore-seed.js`):

```js
const admin = require('firebase-admin');
const serviceAccount = require(process.env.GOOGLE_APPLICATION_CREDENTIALS);

admin.initializeApp({ credential: admin.credential.cert(serviceAccount) });
const db = admin.firestore();

async function seed(uid) {
  const u = db.collection('users').doc(uid);
  await u.set({ uid, displayName: 'Seed User', email: 'seed@example.com', createdAt: new Date().toISOString() });

  await u.collection('subjects').doc('math').set({ id: 'math', name: 'Mathematics', color: '#FF5722' });
  await u.collection('subjects').doc('phy').set({ id: 'phy', name: 'Physics', color: '#3F51B5' });

  await u.collection('assignments').doc('a1').set({ id: 'a1', title: 'Read Chapter 1', subjectId: 'math', dueDate: new Date().toISOString(), completed: false });
  console.log('seeded', uid);
}

if (require.main === module) {
  const uid = process.argv[2] || 'test-user-1';
  seed(uid).catch(console.error);
}
```

Run the seeder:

```bash
npm init -y
npm install firebase-admin
export GOOGLE_APPLICATION_CREDENTIALS="/path/to/service-account.json"
node seed/firestore-seed.js YOUR_UID
```

This will create a `users/{YOUR_UID}` document and a few sample child docs.

---

DEBUGGING & DIAGNOSTICS

Common issues and how to diagnose them:

- Permission denied (`missing or insufficient permissions`):
  - Confirm Firestore rules were published in the same Firebase project.
  - Verify `lib/firebase_options.dart` is for that project.
  - Confirm the signed-in UID matches the document path being written to.

- Firebase init failures:
  - Check console logs for the initialization error.
  - Confirm network access and API keys in `lib/firebase_options.dart`.

- Data not appearing in the console after write:
  - Confirm the write completed (no exception in the Flutter logs).
  - Check Firestore indexes or field types if writes succeed but queries fail.

Diagnostic tips:

- Add temporary `print()` statements in `AppProvider.save()` and
  `FirebaseService` to log the exact error and stack trace. Remove these
  once the issue is resolved.
- Use the Firebase Emulator Suite for offline testing and CI-friendly tests.

---

TESTS AND CI

Run tests locally with:

   flutter test

Notes for CI:

- Consider running the Firebase Emulator in CI for integration tests that
  require Firestore reads/writes.
- Keep the test matrix small: test core provider logic and models; UI tests
  can be run as optional integration jobs.

---

CONTRIBUTING

We welcome contributions. A suggested workflow:

1. Fork and clone the repository.
2. Create a feature branch off `devTanish` for your change.
3. Run `flutter analyze` and `flutter test` before creating a PR.
4. Add unit tests for logic changes where possible.
5. Open a PR with a focused description and screenshots for UI changes.

Coding style and expectations:

- Prefer small, single-purpose widgets over large monoliths.
- Keep business logic in providers/services and keep widgets thin.
- Follow existing code patterns for naming and file layout.

---

CHANGELOG (recent & notable)

- Provider auto-reload on authentication: the provider now reloads state
  immediately after a successful sign-in so data appears without further action.
- Logging improvements in `AppProvider.save()` to capture persistence errors
  and stack traces during debugging.
- Temporary debug helpers were used to validate Firestore rules and removed.

---

LICENSE

Add a `LICENSE` file to the repository root (for example MIT). Choose a
license that matches how you want others to use your code.

---

FURTHER WORK / OPTIONAL TASKS

- Add `seed/firestore-seed.js` under a `seed/` directory in the repo.
- Ensure `AuthService` creates or ensures existence of `users/{uid}` on sign-in
  (currently profile creation may only occur on sign-up).
- Add integration tests using the Firebase Emulator Suite.

---

CONTACT

If you need help implementing any of the optional tasks above, reply with the
task you'd like done and I will implement it in the repository.

Happy coding — and good studying! ✨
